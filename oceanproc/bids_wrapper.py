#!/usr/bin/env python3

from argparse import ArgumentParser
from collections import OrderedDict
from glob import glob
from pathlib import Path
import json
import os
import re
import shlex
import shutil
import subprocess
from textwrap import dedent
import xml.etree.ElementTree as et
from .utils import exit_program_early, prompt_user_continue


def remove_unusable_runs(xml_file:Path, bids_data_path:Path, subject:str):
    """
    Will remove unusable scans from list of scans after dcm2bids has run.

    :param xml_file: Path to XML file containing quality information generated by XNAT.
    :type xml_file: pathlib.Path
    :param bids_data_path: Path to directory containing BIDS-compliant data for the given subject.
    :type bids_data_path: pathlib.Path
    :param subject: Subject ID used in BIDS-compliant data (for example, if 'sub-5000', subject is '5000').
    :type subject: str

    """
    print("####### Removing the scans marked 'unusable' #######")

    if not xml_file.exists():
        exit_program_early(f"Path {str(xml_file)} does not exist.")
        
    tree = et.parse(xml_file)
    prefix = "{" + str(tree.getroot()).split("{")[-1].split("}")[0] + "}"
    scan_element_list = list(tree.iter(f"{prefix}scans"))
    
    if len(scan_element_list) != 1:
        exit_program_early(f"Error parsing the xml file provided. Found none or more than one scan groups")
    
    scans = scan_element_list[0]
    quality_pairs = {int(s.get("ID")) : s.find(f"{prefix}quality").text
                     for s in scans}
    
    if len(quality_pairs) == 0:
        exit_program_early("Could not find scan quality information in the given xml file.") 
    
    json_paths = sorted(list(p for p in (bids_data_path / f"sub-{subject}/").rglob("*.json"))) # if re.search(json_re, p.as_posix()) != None)
    nii_paths = sorted(list(p for p in (bids_data_path / f"sub-{subject}/").rglob("*.nii.gz"))) # if re.search(json_re, p.as_posix()) != None)

    if len(json_paths) == 0 or len(nii_paths) == 0:
        exit_program_early("Could not find Nifti or JSON sidecar files in the bids directory.")

    if len(json_paths) != len(nii_paths):
        exit_program_early("Unequal amount of NIFTI and JSON files found")
 
    for p_json, p_nii in zip(json_paths, nii_paths):
        j = json.load(p_json.open()) 
        if quality_pairs[j["SeriesNumber"]] == "unusable":
            print(f"  Removing series {j['SeriesNumber']}: NIFTI:{p_nii}, JSON:{p_json}")
            os.remove(p_json) 
            os.remove(p_nii) 


def run_dcm2bids(source_dir:Path, 
                 bids_output_dir:Path, 
                 config_file:Path, 
                 subject:str, 
                 session:str, 
                 nordic_config:Path=None,
                 nifti:bool=False):
    """
    Run dcm2bids with a given set of parameters.

    :param source_dir: Path to 'sourcedata' directory (or wherever DICOM data is kept).
    :type source_dir: pathlib.Path
    :param bids_output_dir: Path to the bids directory to store the newly made NIFTI files
    :type bids_output_dir: pathlib.Path
    :param config_file: Path to dcm2bids config file, which maps raw sourcedata to BIDS-compliant counterpart
    :type config_file: pathlib.Path
    :param subject: Subject name (ex. 'sub-5000', subject would be '5000')
    :type subject: str
    :param session: Session name (ex. 'ses-01', session would be '01')
    :type session: str
    :param nordic_config: Path to second dcm2bids config file, needed for additional post processing that one BIDS config file can't handle.
    :type nordic_config: pathlib.Path
    :param nifti: Specify that the soure directory contains NIFTI files instead of DICOM
    :type nifti: bool
    :raise RuntimeError: If dcm2bids exits with a non-zero exit code.
    """

    for p in [source_dir, bids_output_dir, config_file]:
        if not p.exists():
            exit_program_early(f"Path {str(p)} does not exist.")

    if shutil.which('dcm2bids') == None:
            exit_program_early("Cannot locate program 'dcm2bids', make sure it is in your PATH.")
    
    tmp_path = bids_output_dir / f"tmp_dcm2bids/sub-{subject}_ses-{session}"
    
    def clean_up():
        try:
            shutil.rmtree(tmp_path)
        except Exception as e:
            print(e)
            print(f"There was a problem deleting the temporary directory at {tmp_path}")
    
    if (path_that_exists := bids_output_dir/f"sub-{subject}/ses-{session}").exists():
        ans = prompt_user_continue(dedent(f"""
                                    A raw data bids path for this subject and session already exists. 
                                    Would you like to delete its contents and rerun dcm2bids? If not,
                                    dcm2bids will be skipped.
                                          """))
        if ans:
            shutil.rmtree(path_that_exists)
            clean_up()
        else:
            return
        
    nifti_path = None    
    if not nifti:
        print("####### Converting DICOM files into NIFTI #######")
        run_dcm2niix(source_dir=source_dir, 
                     tmp_nifti_dir=tmp_path)
        nifti_path = tmp_path
    else:
        nifti_path = source_dir
    helper_command = shlex.split(f"""{shutil.which('dcm2bids')} 
                                 --bids_validate 
                                 --skip_dcm2niix
                                 -d {str(nifti_path)} 
                                 -p {subject} 
                                 -s {session} 
                                 -c {str(config_file)} 
                                 -o {str(bids_output_dir)}
                                 """)
    try:
        print("####### Running first round of Dcm2Bids ########")
        # subprocess.check_output(helper_command) # run helper command to generate json/.nii files; throw error if fail
        with subprocess.Popen(helper_command, stdout=subprocess.PIPE) as p:
            while p.poll() == None:
                text = p.stdout.read1().decode("utf-8", "ignore")
                print(text, end="", flush=True)
            if p.poll() != 0:
                raise RuntimeError("'dcm2bids' has ended with a non-zero exit code.")
            
        if nordic_config:
            if not nordic_config.exists():
                exit_program_early(f"Path {nordic_config} does not exist.")

            nordic_run_command = shlex.split(f"""{shutil.which('dcm2bids')} 
                                            --bids_validate
                                            --skip_dcm2niix
                                            -d {str(nifti_path)} 
                                            -p {subject}
                                            -s {session}
                                            -c {str(nordic_config)}
                                            -o {str(bids_output_dir)}
                                            """)
            print("####### Running second round of Dcm2Bids ########")
            # subprocess.check_output(nordic_run_command)
            with subprocess.Popen(nordic_run_command, stdout=subprocess.PIPE) as p:
                while p.poll() == None:
                    text = p.stdout.read1().decode("utf-8", "ignore")
                    print(text, end="", flush=True)
                if p.poll() != 0:
                    raise RuntimeError("'dcm2bids' has ended with a non-zero exit code.")
                
            # Clean up NORDIC files
            separate_nordic_files = glob(f"{str(bids_output_dir)}/sub-{subject}/ses-{session}/func/*_part-*")
            for f in separate_nordic_files:
                os.remove(f)

    except RuntimeError or subprocess.CalledProcessError as e:
        print(e)
        exit_program_early("Problem running 'dcm2bids'.", clean_up)
    clean_up()


def run_dcm2niix(source_dir:Path, 
                 tmp_nifti_dir:Path,
                 clean_up_func=None):
    """
    Run dcm2niix with the given input and output directories.

    :param source_dir: Path to 'sourcedata' directory (or wherever DICOM data is kept).
    :type source_dir: pathlib.Path
    :param tmp_nifti_dir: Path to the directory to store the newly made NIFTI files
    :type tmp_nifti_dir: pathlib.Path
    """
    
    if not source_dir.exists():
        exit_program_early(f"Path {source_dir} does not exist.")
    elif shutil.which('dcm2niix') == None:
        exit_program_early("Cannot locate program 'dcm2niix', make sure it is in your PATH.")

    if not tmp_nifti_dir.exists():
        tmp_nifti_dir.mkdir(parents=True)
    
    helper_command = shlex.split(f"""{shutil.which('dcm2niix')} 
                                -b y
                                -ba y
                                -z y
                                -f %3s_%f_%p_%t
                                -o {str(tmp_nifti_dir)}
                                {str(source_dir)}
                                """)
    try:
        with subprocess.Popen(helper_command, stdout=subprocess.PIPE) as p:
            while p.poll() == None:
                text = p.stdout.read1().decode("utf-8", "ignore")
                print(text, end="", flush=True)
            if p.poll() != 0:
                raise RuntimeError("'dcm2bniix' has ended with a non-zero exit code.")
    except RuntimeError or subprocess.CalledProcessError as e:
        print(e)
        exit_program_early("Problem running 'dcm2niix'.", 
                           exit_func=clean_up_func if clean_up_func else None)
        
    # Delete extra files from short runs
    for f in tmp_nifti_dir.glob("*a.nii.gz"):
        os.remove(f)
    for f in tmp_nifti_dir.glob("*a.json"):
        os.remove(f)
    
    

def dicom_to_bids(subject:str, 
                  session:str, 
                  source_dir:Path, 
                  bids_dir:Path, 
                  xml_path:Path, 
                  bids_config:Path,
                  nordic_config:Path=None,
                  nifti=False):
    
    """
    Facilitates the conversion of DICOM data into NIFTI data in BIDS format, and the removal of data marked 'unusable'.

    :param subject: Subject name (ex. 'sub-5000', subject would be '5000')
    :type subject: str
    :param session: Session name (ex. 'ses-01', session would be '01')
    :type session: str
    :param source_dir: Path to 'sourcedata' directory (or wherever DICOM data is kept).
    :type source_dir: pathlib.Path
    :param bids_dir: Path to the bids directory to store the newly made NIFTI files
    :type bids_dir: pathlib.Path
    :param bids_config: Path to dcm2bids config file, which maps raw sourcedata to BIDS-compliant counterpart
    :type bids_config: pathlib.Path
    :param nordic_config: Path to second dcm2bids config file, needed for additional post processing if NORDIC data that one BIDS config file can't handle.
    :type nordic_config: pathlib.Path
    :param nifti: Specify that the soure directory contains NIFTI files instead of DICOM
    :type nifti: bool
    """

    run_dcm2bids(source_dir, bids_dir, bids_config, subject, session, nordic_config, nifti)
    remove_unusable_runs(xml_path, bids_dir, subject)


if __name__ == "__main__":
    parser = ArgumentParser(prog="bids_wrapper.py",
                                    description="wrapper script for dcm2bids",
                                    epilog="WIP")
    parser.add_argument("-su", "--subject", required=True, 
                        help="Subject ID")
    parser.add_argument("-se","--session", required=True, 
                        help="Session ID")
    parser.add_argument("-sd", "--source_data", type=Path, required=True,
                        help="Path to directory containing this session's DICOM files")
    parser.add_argument("-b", "--bids_path", type=Path, required=True, 
                        help="Path to the bids directory to store the newly made NIFTI files")
    parser.add_argument("-x", "--xml_path", type=Path, required=True, 
                        help="Path to this session's XML file")
    parser.add_argument("-c", "--bids_config", type=Path, required=True, 
                        help="dcm2bids config json file")
    parser.add_argument("-n", "--nordic_config", type=Path,
                        help="Second dcm2bids config json file used for NORDIC processing")
    parser.add_argument("--nifti", action='store_true', 
                        help="Flag to specify that the source directory contains files of type NIFTI (.nii/.jsons) instead of DICOM")
    args = parser.parse_args()
    
    dicom_to_bids(subject=args.subject,
                  session=args.session,
                  source_dir=args.source_data,
                  bids_dir=args.bids_path,
                  xml_path=args.xml_path,
                  bids_config=args.bids_config,
                  nordic_config=args.nordic_config,
                  nifti=args.nifti)
